[{"categories":null,"contents":" Fixed a bug Various commits  ","permalink":"https://joemattiello.dev/projects/contributions/monomac/","tags":["c#","Objective-C","macOS","iOS","tvOS"],"title":"MonoMAC"},{"categories":null,"contents":"Provenance is an open source, multi-platform emulator for iOS and tvOS. Originally created by James Addyman as a part of OpenEMU to iOS for NES, SNES and Genesis systems.\nThe project was eventually ported by myself to full Swift and protocol oriented design to more easily incorporate other open source emulator\u0026rsquo;s engines into our code base.\nI got involved and eventually took over the project. We were the first team to deliver full performance Nintendo 64 emulation to iOS without jailbreaks that rely on JIY compilation.\nWe also have the only modern port of Jaguar, ported by myself from legacy Windows code Open Jaguar, to ARM64 and SIMD C. Other ports include Mednafen\u0026rsquo;s Playstation 1, Reicast\u0026rsquo;s only working iOS port of Dreamcast and more systems in development such as Sega Saturn and Sony PSP.\nWiki: https://wiki.provenance-emu.com\nCommunity Chat: Discord\nTwitter: @provenanceapp\n","permalink":"https://joemattiello.dev/projects/creations/provenance-emu/","tags":["Swift","Objective-C","AArch64","Assembly","iOS","tvOS","MVVM","Rx","Realm"],"title":"Provenance EMU"},{"categories":null,"contents":" Various commits  ","permalink":"https://joemattiello.dev/projects/contributions/termkit/","tags":["Swift","macOS","iOS","tvOS"],"title":"TermKit"},{"categories":null,"contents":" Various commits  ","permalink":"https://joemattiello.dev/projects/contributions/xmlcoder/","tags":["Swift","Objective-C","macOS","iOS","tvOS"],"title":"XMLCoder"},{"categories":null,"contents":"Hero Transitions is an open source project that I voluneteered to take ownership of in 2019.\nThis project is also served as a Cocoapod, the publishing of which is automated through GitHub actions I authored along with a suite of other CI/CD tools to assist with administrating such an important open-source project.\nThis project also support SwiftPM and Carthage.\n Hero is a library for building iOS view controller transitions. It provides a declarative layer on top of the UIKit\u0026rsquo;s cumbersome transition APIs—making custom transitions an easy task for developers.\n      \nHero is similar to Keynote\u0026rsquo;s Magic Move. It checks the heroID property on all source and destination views. Every matched view pair is then automatically transitioned from its old state to its new state.\nHero can also construct animations for unmatched views. It is easy to define these animations via the heroModifiers property. Hero will run these animations alongside the Magic Move animations. All of these animations can be interactively controlled by user gestures.\nAt view controller level, Hero provides several template transitions that you can set through heroModalAnimationType, heroNavigationAnimationType, and heroTabBarAnimationType. These can be used as the foundation of your custom transitions. Combine with heroID \u0026amp; heroModifiers to make your own unique transitions.\nBy default, Hero provides dynamic duration based on the Material Design Motion Guide. Duration is automatically determined by changes to distance and size—saving you the hassle, while providing consistent and delightful animations.\nHero doesn\u0026rsquo;t make any assumptions about how the view is built or structured. It won\u0026rsquo;t modify any of your views' states other than hiding them during the animation. This makes it work with Auto Layout, programmatic layout, UICollectionView (without modifying its layout object), UITableView, UINavigationController, UITabBarController, etc\u0026hellip;\nUsage Example 1 View Controller 1 redView.hero.id = \u0026#34;ironMan\u0026#34; blackView.hero.id = \u0026#34;batMan\u0026#34; View Controller 2 self.hero.isEnabled = true redView.hero.id = \u0026#34;ironMan\u0026#34; blackView.hero.id = \u0026#34;batMan\u0026#34; whiteView.hero.modifiers = [.translate(y:100)] Usage Example 2 View Controller 1 greyView.hero.id = \u0026#34;skyWalker\u0026#34; View Controller 2 self.hero.isEnabled = true greyView.hero.id = \u0026#34;skyWalker\u0026#34; // collectionView is the parent view of all red cells collectionView.hero.modifiers = [.cascade] for cell in redCells { cell.hero.modifiers = [.fade, .scale(0.5)] } You can do these in the storyboard too!\nInstallation CocoaPods Add the following entry to your Podfile:\npod \u0026#39;Hero\u0026#39; Then run pod install.\nDon\u0026rsquo;t forget to import Hero in every file you\u0026rsquo;d like to use Hero.\nCarthage Add the following entry to your Cartfile:\ngithub \u0026#34;HeroTransitions/Hero\u0026#34; Then run carthage update.\nIf this is your first time using Carthage in the project, you\u0026rsquo;ll need to go through some additional steps as explained over at Carthage.\nAccio Add the following to your Package.swift:\n.package(url: \u0026#34;https://github.com/HeroTransitions/Hero.git\u0026#34;, .upToNextMajor(from: \u0026#34;1.4.0\u0026#34;)), Next, add Hero to your App targets dependencies like so:\n.target( name: \u0026#34;App\u0026#34;, dependencies: [ \u0026#34;Hero\u0026#34;, ] ), Then run accio update.\nSwift Package Manager To integrate using Apple\u0026rsquo;s Swift package manager, add the following as a dependency to your Package.swift:\n.package(url: \u0026#34;https://github.com/HeroTransitions/Hero.git\u0026#34;, .upToNextMajor(from: \u0026#34;1.3.0\u0026#34;)) and then specify \u0026quot;Hero\u0026quot; as a dependency of the Target in which you wish to use Hero. Here\u0026rsquo;s an example PackageDescription:\n// swift-tools-version:4.0 import PackageDescription let package = Package( name: \u0026#34;MyPackage\u0026#34;, products: [ .library( name: \u0026#34;MyPackage\u0026#34;, targets: [\u0026#34;MyPackage\u0026#34;]), ], dependencies: [ .package(url: \u0026#34;https://github.com/HeroTransitions/Hero.git\u0026#34;, .upToNextMajor(from: \u0026#34;1.6.1\u0026#34;)) ], targets: [ .target( name: \u0026#34;MyPackage\u0026#34;,1.6.1 dependencies: [\u0026#34;Hero\u0026#34;]) ] ) Manually  Drag the Sources folder anywhere in your project.  Documentations Checkout the WIKI PAGES (Usage Guide) for documentations.\nFor more up-to-date ones, please see the header-doc. (use alt+click in Xcode) Interactive Transition Tutorials Interactive transitions with Hero (Part 1)\nFAQ Not able to use Hero transition even when self.hero.isEnabled is set to true Make sure that you have also enabled self.hero.isEnabled on the navigation controller if you are doing a push/pop inside the navigation controller.\nViews being covered by another matched view during the transition Matched views use global coordinate space while unmatched views use local coordinate space by default. Local coordinate spaced views might be covered by other global coordinate spaced views. To solve this, use the useGlobalCoordinateSpace modifier on the views being covered. Checkout Coordinate Space Wiki page for details.\nPush animation is shown along side my custom animation This is the default animation for navigation controller provided by Hero. To disable the push animation, set self.hero.navigationAnimationType to .fade or .none on the navigation controller.\nHow do I use a different default animation when dismissing You can use the animation type .selectBy(presenting:dismissing) to specify a different default animation for dismiss.\nFor example:\nself.hero.modalAnimationType = .selectBy(presenting:.zoom, dismissing:.zoomOut) Contribute We welcome any contributions. Please read the Contribution Guide. {\u0026ldquo;mode\u0026rdquo;:\u0026ldquo;full\u0026rdquo;,\u0026ldquo;isActive\u0026rdquo;:false}\n","permalink":"https://joemattiello.dev/projects/creations/hero/","tags":["Swift","Objective-C","AArch64","iOS","tvOS"],"title":"Hero"},{"categories":null,"contents":"RxReachability is an open source project that I voluneteered to take ownership of in 2019.\nIt\u0026rsquo;s a small but vital project to many apps in the iOS community for providing a simple RxSwift bindable interface for use in funciontal code dependendant on network connectivity state.\nThis project is also served as a Cocoapod, the publishing of which is automated through GitHub actions I authored along with a suite of other CI/CD tools to assist with administrating such an important open-source project.\nThis project also support SwiftPM and Carthage.\n RxReachability      RxReachability adds easy to use RxSwift bindings for ReachabilitySwift. You can react to network reachability changes and even retry observables when network comes back up.\nAvailable APIs RxReachability adds the following RxSwift bindings:\n reachabilityChanged: Observable\u0026lt;Reachability\u0026gt; status: Observable\u0026lt;Reachability.NetworkStatus\u0026gt; isReachable: Observable\u0026lt;Bool\u0026gt; isConnected: Observable\u0026lt;Void\u0026gt; isDisconnected: Observable\u0026lt;Void\u0026gt;  Common Usage 1. Be sure to store an instance of Reachability in your ViewController or similar, and start/stop the notifier on viewWillAppear and viewWillDisappear methods. class ViewController: UIViewController { let disposeBag = DisposeBag() var reachability: Reachability? override func viewDidLoad() { super.viewDidLoad() reachability = Reachability() } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) try? reachability?.startNotifier() } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) reachability?.stopNotifier() } } 2. Subscribe to any of the bindings to know when a change happens. extension ViewController { let disposeBag = DisposeBag() func bindReachability() { reachability?.rx.reachabilityChanged .subscribe(onNext: { reachability: Reachability in print(\u0026#34;Reachability changed: \\(reachability.currentReachabilityStatus)\u0026#34;) }) .disposed(by: disposeBag) reachability?.rx.status .subscribe(onNext: { status: Reachability.NetworkStatus in print(\u0026#34;Reachability status changed: \\(status)\u0026#34;) }) .disposed(by: disposeBag) reachability?.rx.isReachable .subscribe(onNext: { isReachable: Bool in print(\u0026#34;Is reachable: \\(isReachable)\u0026#34;) }) .disposed(by: disposeBag) reachability?.rx.isConnected .subscribe(onNext: { print(\u0026#34;Is connected\u0026#34;) }) .disposed(by: disposeBag) reachability?.rx.isDisconnected .subscribe(onNext: { print(\u0026#34;Is disconnected\u0026#34;) }) .disposed(by: disposeBag) } Static Usage 1. Be sure to store an instance of Reachability somewhere on your AppDelegate or similar, and start the notifier. import Reachability @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var reachability: Reachability? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -\u0026gt; Bool { reachability = Reachability() try? reachability?.startNotifier() return true } } 2. Subscribe to any of the bindings to know when a change happens. import Reachability import RxReachability import RxSwift class ViewController: UIViewController { let disposeBag = DisposeBag() override func viewDidLoad() { super.viewDidLoad() Reachability.rx.reachabilityChanged .subscribe(onNext: { reachability: Reachability in print(\u0026#34;Reachability changed: \\(reachability.currrentReachabilityStatus)\u0026#34;) }) .disposed(by: disposeBag) Reachability.rx.status .subscribe(onNext: { status: Reachability.NetworkStatus in print(\u0026#34;Reachability status changed: \\(status)\u0026#34;) }) .disposed(by: disposeBag) Reachability.rx.isReachable .subscribe(onNext: { isReachable: Bool in print(\u0026#34;Is reachable: \\(isReachable)\u0026#34;) }) .disposed(by: disposeBag) Reachability.rx.isConnected .subscribe(onNext: { print(\u0026#34;Is connected\u0026#34;) }) .disposed(by: disposeBag) Reachability.rx.isDisconnected .subscribe(onNext: { print(\u0026#34;Is disconnected\u0026#34;) }) .disposed(by: disposeBag) } Advanced Usage With RxReachability you can also add a retry when network comes back up with a given timeout. This does require you to have a stored instance of Reachability though.\nfunc request(somethingId: Int) -\u0026gt; Observable\u0026lt;Something\u0026gt; { return network.request(.something(somethingId)) .retryOnConnect(timeout: 30) .map { Something(JSON: $0) } } Installation Installation via CocoaPods To integrate RxReachability into your Xcode project using CocoaPods, simply add the following line to your Podfile:\npod \u0026#39;RxReachability\u0026#39;, ~\u0026gt; \u0026#39;1.2.1\u0026#39; Installation via Carthage To integrate RxReachability into your Xcode project using CocoaPods, simply add the following line to your Cartfile:\ngithub RxSwiftCommunity/RxReachability ~\u0026gt; 1.2.1 Installation via Swift Package Manager (SPM) To integrate RxReachability into your Xcode project using SPM, simply add the following line to your Package.swift:\n.package(url: \u0026#34;https://github.com/RxSwiftCommunity/RxReachability\u0026#34;, .upToNextMajor(from: \u0026#34;1.2.1\u0026#34;)), Example To run the example project, clone the repo, and run pod install from the Example directory first.\nLicense This library belongs to RxSwiftCommunity.\nRxReachability is available under the MIT license. See the LICENSE file for more info. {\u0026ldquo;mode\u0026rdquo;:\u0026ldquo;full\u0026rdquo;,\u0026ldquo;isActive\u0026rdquo;:false}\n","permalink":"https://joemattiello.dev/projects/creations/rxreachability/","tags":["Swift","Objective-C","macOS","iOS","tvOS","MVVM","Rx","Realm"],"title":"RxReachability"},{"categories":null,"contents":"PinCache.swift is a custom Swift re-write of Pintrist\u0026rsquo;s PINCache, that retrains full Objective-C backwards compatibility while enabling optional advanced Swift language features using protocols and default implimentations.\n PINCache   \nFast, non-deadlocking parallel object cache for iOS and OS X. PINCache is a fork of TMCache re-architected to fix issues with deadlocking caused by heavy use. It is a key/value store designed for persisting temporary objects that are expensive to reproduce, such as downloaded data or the results of slow processing. It is comprised of two self-similar stores, one in memory (PINMemoryCache) and one on disk (PINDiskCache), all backed by GCD and safe to access from multiple threads simultaneously. On iOS, PINMemoryCache will clear itself when the app receives a memory warning or goes into the background. Objects stored in PINDiskCache remain until you trim the cache yourself, either manually or by setting a byte or age limit.\nPINCache and PINDiskCache accept any object conforming to NSCoding. Put things in like this:\nObjective-C\nUIImage *img = [[UIImage alloc] initWithData:data scale:[[UIScreen mainScreen] scale]]; [[PINCache sharedCache] setObject:img forKey:@\u0026#34;image\u0026#34; block:nil]; // returns immediately Swift\nlet img = UIImage(data: data, scale:UIScreen.main.scale) PINCache.shared().setObject(img, forKey: \u0026#34;img\u0026#34;) Get them back out like this:\nObjective-C\n[[PINCache sharedCache] objectForKeyAsync:@\u0026#34;image\u0026#34; block:^(PINCache *cache, NSString *key, id object) { UIImage *image = (UIImage *)object; NSLog(@\u0026#34;image scale: %f\u0026#34;, image.scale); }]; Swift\nPINCache.shared().object(forKey: \u0026#34;image\u0026#34;) { (cache, key, object) in if let image = object as? UIImage { print(\u0026#34;image scale: %f\u0026#34;, image.scale) } } Both PINMemoryCache and PINDiskCache use locks to protect reads and writes. PINCache coordinates them so that objects added to memory are available immediately to other threads while being written to disk safely in the background. Both caches are public properties of PINCache, so it\u0026rsquo;s easy to manipulate one or the other separately if necessary.\nCollections work too. Thanks to the magic of NSKeyedArchiver, objects repeated in a collection only occupy the space of one on disk:\nObjective-C\nNSArray *images = @[ image, image, image ]; [[PINCache sharedCache] setObject:images forKey:@\u0026#34;images\u0026#34;]; NSLog(@\u0026#34;3 for the price of 1: %d\u0026#34;, [[[PINCache sharedCache] diskCache] byteCount]); Swift\n// In Swift, Array, String, and Dictionary are all value types. let images = [image, image, image] as NSArray // Cast to NSArray PINCache.shared.setObject(images, forKey: \u0026#34;images\u0026#34;) print(\u0026#34;3 for the prices of 1: %d\u0026#34;, PINCache.shared.diskCache.byteCount) Installation Manually Download the latest tag and drag the PINCache folder into your Xcode project.\nInstall the docs by double clicking the .docset file under docs/, or view them online at cocoadocs.org\nGit Submodule git submodule add https://github.com/pinterest/PINCache.git git submodule update --init  CocoaPods Add PINCache to your Podfile and run pod install.\nCarthage Add the following line to your Cartfile and run carthage update --platform ios. Then follow this instruction of Carthage to embed the framework.\ngithub \u0026quot;pinterest/PINCache\u0026quot;\nRequirements PINCache requires iOS 8.0, tvOS 9.0, watchOS 2.0 or macOS 10.8 and greater.\nContact Garrett Moon\nLicense Copyright 2013 Tumblr, Inc. Copyright 2015 Pinterest, Inc.\nLicensed under the Apache License, Version 2.0 (the \u0026ldquo;License\u0026rdquo;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. {\u0026ldquo;mode\u0026rdquo;:\u0026ldquo;full\u0026rdquo;,\u0026ldquo;isActive\u0026rdquo;:false}\n","permalink":"https://joemattiello.dev/projects/creations/pincache_swift/","tags":["Swift","iOS","tvOS","github"],"title":"PinCache.swift"},{"categories":null,"contents":"","permalink":"https://joemattiello.dev/projects/contributions/pbxbuild/","tags":null,"title":""},{"categories":null,"contents":"","permalink":"https://joemattiello.dev/resume/","tags":null,"title":""},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml\n[outputs] home = [\u0026quot;HTML\u0026quot;, \u0026quot;JSON\u0026quot;] Searching additional files To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category\n... \u0026quot;contents\u0026quot;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026quot;tags\u0026quot;:{{ .Params.tags | jsonify }}{{end}}, \u0026quot;categories\u0026quot; : {{ .Params.categories | jsonify }}, ... Edit fuse.js options to Search static/js/search.js\nkeys: [ \u0026quot;title\u0026quot;, \u0026quot;contents\u0026quot;, \u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot; ] ","permalink":"https://joemattiello.dev/search/","tags":null,"title":"Search Results"}]